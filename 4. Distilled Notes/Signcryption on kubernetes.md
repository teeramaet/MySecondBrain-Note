However, there are various technical challenges when it comes to verifying the signature for a Kubernetes resource at the admission controller because a signed resource is rewritten automatically by internal cluster work and many requests that include internal mutation without a signature are generated.

The differences between the signed resource in the admission request and the signature message occur automatically in Kubernetes and conducts signature verification properly by using DryRun.

Problems:
- the Kubernetes resource is rewritten internally before the admission controller receives the signed Kubernetes resource. The Kubernetes resource is represented by YAML [20], and the entire content of YAML is used as a message to create a signature for protecting the Kubernetes resource. The signed Kubernetes resource is passed on to the admission controller as an admission request when the Kubernetes resource is installed in a cluster. However, the resource in the admission request is different from the original resource at the time of signature generation. In order to verify the signature correctly based on the original resource, we need to handle the difference between the original resource and the resource in the admission request that occurs due to the internal Kubernetes operation.

- the requests originate from not only outside but also inside a cluster. On a Kubernetes, various internal processes are performed as part of the normal operation of the cluster, and related admission requests are generated. These requests that the cluster generates as an internal operation are an expected mutation and cannot be attached to a signature. If all unsigned requests from the cluster are blocked by the admission controller because of no signature, it may affect the cluster. It is necessary to filter out admission requests caused by internal cluster operation from the large number of requests in order to validate and control requests without any negative impacton the cluster.